<!DOCTYPE html>
<html>
<head>
  <title>Hello, world!</title>
  <script src="https://aframe.io/releases/1.0.4/aframe.min.js"></script>
  <script src="https://raw.githack.com/AR-js-org/AR.js/master/aframe/build/aframe-ar.js"></script>
  <script src="https://raw.githack.com/donmccurdy/aframe-extras/master/dist/aframe-extras.loaders.min.js"></script>
  <script src="https://raw.githack.com/AR-js-org/studio-backend/master/src/modules/marker/tools/gesture-detector.js"></script>
  <script src="https://raw.githack.com/AR-js-org/studio-backend/master/src/modules/marker/tools/gesture-handler.js"></script>
</head>
  
<body>
  <script>
    var scene, camera, renderer, clock, deltaTime, totalTime; 
    var arToolkitSource, arToolkitContext;
    var markerRoot1;
    var mesh0, mesh1;

    initialize();
    animate();

    function animate()
    {
      requestAnimationFrame(animate); 
      deltaTime = clock.getDelta(); 
      totalTime += deltaTime; 
      update();
      render(); 
    }

    function update()
    {
      // update artoolkit on every frame
      if ( arToolkitSource.ready !== false ) 
      arToolkitContext.update( arToolkitSource.domElement );
    }

    function render()
    {
      renderer.render( scene, camera ); 
    }

    function initialize()
    {
      scene = new THREE.Scene();
      let ambientLight = new THREE.AmbientLight( 0xcccccc, 1.0 ); 
      scene.add( ambientLight );

      camera = new THREE.Camera(); 
      scene.add(camera);

      renderer = new THREE.WebGLRenderer(
        { 
        antialias : true,
        alpha: true
        });

      
      renderer.setClearColor(new THREE.Color('lightgrey'), 0) 
      renderer.setSize( 320, 240 ); 
      renderer.domElement.style.position = 'absolute' 
      renderer.domElement.style.top = '10px' 
      renderer.domElement.style.left = '10px' 
      document.body.appendChild( renderer.domElement );

      clock = new THREE.Clock();
      deltaTime = 0;
      totalTime = 0;

      arToolkitSource = new THREEx.ArToolkitSource(
        { 
        sourceType : 'webcam',
        });
    

      function onResize()
      {
        arToolkitSource.onResize() 
        arToolkitSource.copySizeTo(renderer.domElement) 
        if ( arToolkitContext.arController !== null ) 
        {
          arToolkitSource.copySizeTo(arToolkitContext.arController.canvas) 
        }
      }
        
      arToolkitSource.init(function onReady()
      { 
        onResize()
      });
        // handle resize event
        window.addEventListener('resize', function(){ onResize()
        });

      arToolkitContext = new THREEx.ArToolkitContext(
        { cameraParametersUrl: '../../data/camera_para.dat', 
        detectionMode: 'mono'
        });

      arToolkitContext.init( function onCompleted()
        { camera.projectionMatrix.copy( arToolkitContext.getProjectionMatrix() ); 
        });

        markerRoot1 = new THREE.Group();
        scene.add(markerRoot1);
        let markerControls1 = new THREEx.ArMarkerControls(arToolkitContext, markerRoot1, 
        {
          type: 'pattern', patternUrl: "marker.patt",
        })

        let geometry1 = new THREE.PlaneBufferGeometry(1,1, 4,4);
        let loader = new THREE.TextureLoader();
        let texture = loader.load( 'grass.jpg', render ); 
        let material1 = new THREE.MeshBasicMaterial( { map: texture } ); 
        mesh1 = new THREE.Mesh( geometry1, material1 ); 
        mesh1.rotation.x = -Math.PI/2;
        markerRoot1.add( mesh1 );

        new THREE.MTLLoader()
          .load( 'puppy.mtl', function ( materials ) 
          {
            materials.preload();
            new THREE.OBJLoader()
              .setMaterials( materials )
              .load( 'puppy.obj', function ( group ) 
                {
                  mesh0 = group.children[0]; 
                  mesh0.material.side = THREE.DoubleSide; 
                  mesh0.position.y = 0.025; 
                  mesh0.scale.set(1.25,1.25,1.25); 
                  mesh0.rotation.y = Math.PI / 2; 
                  markerRoot1.add(mesh0);
                }, onProgress, onError );
          });

          function onProgress(xhr) 
          {
            console.log( (xhr.loaded / xhr.total * 100) + '% loaded' );
          }

          function onError(xhr) 
          {
            console.log( 'An error happened' );
          }
      }

  </script>
</body>
</html>



